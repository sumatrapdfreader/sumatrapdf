#!/usr/bin/env python

import sys
sys.path.append("scripts") # assumes is being run as ./tools/sertxt_test/gen_settings_txt.py

import os, util, struct, types, gen_settings_types
from gen_settings_types import Struct, Field, String, Array, WString
from util import gob_uvarint_encode, gob_varint_encode

g_magic_id = 0x53657454  # 'SetT' as 'Settings''
g_magic_id_str = "SetT"

g_script_dir = os.path.realpath(os.path.dirname(__file__))

def settings_src_dir():
    return util.verify_path_exists(g_script_dir)

def to_win_newlines(s):
    s = s.replace("\r\n", "\n")
    s = s.replace("\n", "\r\n")
    return s

def write_to_file(file_path, s): file(file_path, "w").write(to_win_newlines(s))

def serbin_str(val):
    # empty strings are encoded as 0 (0 length)
    # non-empty strings are encoded as uvariant(len(s)+1)
    # (+1 for terminating 0), followed by string data (including terminating 0)
    if val == None:
        data = gob_uvarint_encode(0)
    else:
        data = gob_uvarint_encode(len(val)+1)
        data = data + val + chr(0)
    return data

def serbin_arr(field):
    assert field.is_array()
    n = len(field.val.values)
    d = gob_uvarint_encode(n)
    for val in field.val.values:
        assert isinstance(val, Struct)
        off = val.offset
        assert type(off) in (types.IntType, types.LongType)
        d += gob_uvarint_encode(off)
    return d

def _serbin(field):
    try:
        assert isinstance(field, Field)
    except:
        print(field)
        raise
    if field.is_signed():
        return gob_varint_encode(long(field.val))
    if field.is_unsigned():
        return gob_uvarint_encode(long(field.val))
    if field.is_string():
        return serbin_str(field.val)
    # floats are serialied as strings
    if field.is_float():
        return serbin_str(str(field.val))
    if field.is_struct():
        off = field.val.offset
        assert type(off) in (types.IntType, types.LongType)
        return gob_uvarint_encode(off)
    if field.is_array():
        return serbin_arr(field)
    assert False, "don't know how to serialize %s" % str(v.typ)

def serbin(v, serialized_vals):
    assert isinstance(v, Field)
    if not v in serialized_vals:
        serialized_vals[v] = _serbin(v)
    return serialized_vals[v]

h_bin_tmpl   ="""// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#ifndef %(file_name)s_h
#define %(file_name)s_h

%(struct_defs)s
#endif
"""

cpp_bin_tmpl = """// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#include "BaseUtil.h"
#include "SerializeBin.h"
#include "%(file_name)s.h"

using namespace serbin;

%(structs_metadata)s
%(values_global_data)s
%(top_level_funcs)s
"""

def ver_from_string(ver_str):
    parts = ver_str.split(".")
    assert len(parts) <= 4
    parts = [int(p) for p in parts]
    for n in parts:
        assert n > 0 and n < 255
    n = 4 - len(parts)
    if n > 0:
        parts = parts + [0]*n
    return parts[0] << 24 | parts[1] << 16 | parts[2] << 8 | parts[3]

# val is a top-level StructVal with primitive types and
# references to other struct types (forming a tree of values).
# we flatten the values into a list, in the reverse order of
# tree traversal
# TODO: this is really not necessary for txt serialization, only binary
# for txt we only use it to make sure we get type definition in the right
# order, which doesn't work for arrays with no elements
def flatten_struct(stru):
    assert isinstance(stru, Struct)
    vals = []
    left = [stru]
    while len(left) > 0:
        stru = left.pop(0)
        assert isinstance(stru, Struct)
        vals += [stru]
        for field in stru.values:
            if field.is_struct():
                if field.val != None:
                    assert isinstance(field.val, Struct)
                    left += [field.val]
            elif field.is_array():
                for v in field.val.values:
                    left += [v]

    vals.reverse()
    return vals

# serialize values in vals to binary and calculate offset of each
# val in encoded data.
# values are serialized in reverse order because
# it would be very complicated to serialize forward
# offsets in variable-length encoding
def serialize_top_level_struct(top_level_struct, serialized_vals):
    vals = flatten_struct(top_level_struct)

    # the first 12 bytes are:
    #  - 4 bytes magic constant (for robustness)
    #  - 4 bytes for version
    #  - 4 bytes offset pointing to a top-level structure
    #      within the data
    offset = 12
    for stru in vals:
        stru.offset = offset
        for field in stru.values:
            data = serbin(field, serialized_vals)
            offset += len(data)
        fields_count = len(stru.values)
        offset = offset + 4 + len(gob_uvarint_encode(fields_count))
    return vals

def data_to_hex(data):
    els = ["0x%02x" % ord(c) for c in data]
    return ", ".join(els)

def dump_val(val):
    print("%s name: %s val: %s offset: %s\n" % (str(val), "", str(val.val), str(val.offset)))

def data_with_comment_as_c(data, comment):
    data_hex = data_to_hex(data)
    return "    %(data_hex)s, // %(comment)s" % locals()

g_addr_to_int_map = {}
# change:
#   <$module.Struct object at 0x7fddfc4c>
# =>
#   Struct_$n where $n maps 0x7fddfc4c => unique integer
def short_object_id(obj):
    global g_addr_to_int_map
    if isinstance(obj, Struct) or isinstance(obj, Array):
        s = str(obj)[1:-1]
        s = ".".join(s.split(".")[1:])
        s = s.replace(" object at ", "@")
        (name, addr) = s.split("@")
        if addr not in g_addr_to_int_map:
            g_addr_to_int_map[addr] = str(len(g_addr_to_int_map))
        return name + "_" + g_addr_to_int_map[addr]
    #if isinstance(obj, Field):
    #    #ssert is_str(obj.val)
    #    return '"' + obj.val + '"'
    assert False, "%s is object of unkown type" % obj

"""
  // $StructName
  0x00, 0x01, // $type $name = $val
  ...
"""
def get_cpp_data_for_struct(stru, serialized_vals):
    assert isinstance(stru, Struct)
    name = stru.name()
    offset = stru.offset
    lines = ["", "    // offset: %s %s" % (hex(offset), short_object_id(stru))]
    assert stru.values not in (None, [])

    # magic id
    data = struct.pack("<I", g_magic_id)
    comment = "magic id '%s'" % g_magic_id_str
    lines += [data_with_comment_as_c(data, comment)]

    # number of fields as uvarint
    fields_count = len(stru.values)
    data = gob_uvarint_encode(fields_count)
    lines += [data_with_comment_as_c(data, "%d fields" % fields_count)]
    size = 4 + len(data)

    for field in stru.values:
        data = serbin(field, serialized_vals)
        size += len(data)
        data_hex = data_to_hex(data)
        var_type = field.c_type()
        var_name = field.name
        if field.is_struct():
            val_str = "NULL"
            if field.val.offset != 0:
                val_str = short_object_id(field.val)
        elif field.is_array():
                val_str = short_object_id(field.val)
        else:
            if field.val == None:
                try:
                    assert isinstance(field.typ, String) or isinstance(field.typ, WString)
                except:
                    print(field)
                    print(field.name)
                    print(field.typ)
                    print(field.val)
                    raise
                val_str = ""
            elif type(field.val) == type(u""):
                # TODO: convert unicode to something acceptable in C sources
                val_str = "<unicode string>"
            elif type(field.val) == type(""):
                val_str = field.val
            else:
                try:
                    val_str = hex(field.val)
                except:
                    print(field)
                    print(field.name)
                    print(field.typ)
                    print(field.val)
                    raise
        s = "    %(data_hex)s, // %(var_type)s %(var_name)s = %(val_str)s" % locals()
        lines += [s]
    return (lines, size)

"""
static uint8_t g$(StructName)Default[] = {
   ... data
};
"""
def gen_cpp_data_for_struct_values(vals, version_str, serialized_vals):
    top_level = vals[-1]
    assert isinstance(top_level, Struct)
    name = top_level.name()
    lines = [""] # will be replaced by: "static const uint8_t g%sDefault[%(total_size)d] = {" at the end

    data = struct.pack("<I", g_magic_id)
    comment = "magic id '%s'" % g_magic_id_str
    lines += [data_with_comment_as_c(data, comment)]
    # version
    data = struct.pack("<I", ver_from_string(version_str))
    comment = "version %s" % version_str
    lines += [data_with_comment_as_c(data, comment)]
    # offset of top-level struct
    data = struct.pack("<I", top_level.offset)
    comment = "top-level struct offset %s" % hex(top_level.offset)
    lines += [data_with_comment_as_c(data, comment)]

    total_size = 12
    for stru in vals:
        (struct_lines, size) = get_cpp_data_for_struct(stru, serialized_vals)
        lines += struct_lines
        total_size += size
    lines += ["};"]
    lines[0] = "static const uint8_t g%sDefault[%d] = {" % (name, total_size)

    return "\n".join(lines)

"""
struct $name {
   $type $field_name;
   ...
};
...
"""
def gen_struct_def(stru, already_generated):

    assert isinstance(stru, Struct)
    if stru in already_generated:
        return []
    name = stru.name()
    lines = ["struct %s {" % name]
    fmt = "    %s %s;"
    for val in stru.values:
        lines += [fmt % (val.c_type(), val.name)]
    lines += ["};\n"]
    return "\n".join(lines)

prototypes_tmpl = """#define %(name)sVersion "%(version_str)s"

%(name)s *Deserialize%(name)s(const uint8_t *data, int dataLen, bool *usedDefaultOut);
uint8_t *Serialize%(name)s(%(name)s *, int *dataLenOut);
void Free%(name)s(%(name)s *);
"""
def gen_struct_defs(vals, version_str):
    top_level = vals[-1]
    assert isinstance(top_level, Struct)
    name = top_level.__class__.__name__
    already_generated = []
    lines = [gen_struct_def(stru, already_generated) for stru in vals]
    lines += [prototypes_tmpl % locals()]
    return "\n".join(lines)


"""
FieldMetadata g${name}FieldMetadata[] = {
    { $type, $offset, &g${name}StructMetadata },
};
"""
def gen_struct_fields(stru):
    assert isinstance(stru, Struct)
    struct_name = stru.name()
    lines = ["FieldMetadata g%(struct_name)sFieldMetadata[] = {" % locals()]
    max_type_len = 0
    for field in stru.values:
        max_type_len = max(max_type_len, len(field.get_typ_enum()))
    max_type_len += 1

    typ_fmt = "%%-%ds " % max_type_len
    for field in stru.values:
        assert isinstance(field, Field)
        typ_enum = field.get_typ_enum() + ","
        typ_enum = typ_fmt % typ_enum
        field_name = field.name
        offset = "offsetof(%(struct_name)s, %(field_name)s)" % locals()
        if field.is_struct():
            field_type = field.typ.name()
            lines += ["    { %(typ_enum)s %(offset)s, &g%(field_type)sMetadata }," % locals()]
        else:
            lines += ["    { %(typ_enum)s %(offset)s, NULL }," % locals()]
    lines += ["};\n"]
    return lines

"""
StructMetadata g${name}StructMetadata = { $size, $nFields, $fields };
"""
def gen_structs_metadata(structs):
    lines = []
    for stru in structs:
        struct_name = stru.name()
        nFields = len(stru.values)
        fields = "&g%sFieldMetadata[0]" % struct_name
        lines += gen_struct_fields(stru)
        lines += ["StructMetadata g%(struct_name)sMetadata = { sizeof(%(struct_name)s), %(nFields)d, %(fields)s };\n" % locals()]
    return "\n".join(lines)

top_level_funcs_bin_tmpl = """
%(name)s *Deserialize%(name)s(const uint8_t *data, int dataLen, bool *usedDefaultOut)
{
    void *res = NULL;
    res = Deserialize(data, dataLen, %(name)sVersion, &g%(name)sMetadata);
    if (res) {
        *usedDefaultOut = false;
        return (%(name)s*)res;
    }
    res = Deserialize(&g%(name)sDefault[0], sizeof(g%(name)sDefault), %(name)sVersion, &g%(name)sMetadata);
    CrashAlwaysIf(!res);
    *usedDefaultOut = true;
    return (%(name)s*)res;
}

uint8_t *Serialize%(name)s(%(name)s *val, int *dataLenOut)
{
    return Serialize((const uint8_t*)val, %(name)sVersion, &g%(name)sMetadata, dataLenOut);
}

void Free%(name)s(%(name)s *val)
{
    FreeStruct((uint8_t*)val, &g%(name)sMetadata);
}
"""

def gen_top_level_funcs_bin(vals):
    top_level = vals[-1]
    assert isinstance(top_level, Struct)
    name = top_level.name()
    return top_level_funcs_bin_tmpl % locals()


def gen_bin():
    dst_dir = settings_src_dir()

    val = gen_settings_types.Settings()
    serialized_vals = {}
    vals = serialize_top_level_struct(val, serialized_vals)
    version = "2.3"
    struct_defs = gen_struct_defs(vals, version)
    file_name = "SettingsSumatraBin"
    file_path_base = os.path.join(os.path.dirname(dst_dir), file_name)
    write_to_file(file_path_base + ".h",  h_bin_tmpl % locals())

    structs_metadata = gen_structs_metadata(vals)

    values_global_data = gen_cpp_data_for_struct_values(vals, version, serialized_vals)
    top_level_funcs = gen_top_level_funcs_bin(vals)
    write_to_file(os.path.join(file_path_base + ".cpp"), cpp_bin_tmpl % locals())

def main():
    gen_bin()

if __name__ == "__main__":
    main()
