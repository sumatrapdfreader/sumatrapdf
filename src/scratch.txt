create build.ts to be executed with bun that runs msbuild command to build
----
in build.ts remove ./out/dbg64/SumatraPDF.exe before running msbuild
----
in StrUtil.cpp and StrUtil.h implement:
struct Str {
  char* s;
  int len;
  Str();
  explicit Str(char* s);
  explicit Str(char* s, int len);
};
add StrL(s) macro that returns Str{s, (int)sizeof(s) - 1}
---
run bun add to add types for node and bun
---
in BaseUtil.cpp, BaseUtil.h add atomic counters and info to PoolAllocator
- count total number of allocation
- total amount of allocated memory
- max allocated memory between calls to Reset()
- max allocations between calls to Reset()
---
remove AtomicInt class from src/utils/BaseUtil.h and src/utils/BaseUtil.cpp
instead add a typedef AtomicInt = LONG and replace the use of AtomicInt methods with AtomicInt* functions that use Interlocked* win32 apis, for example void AtomicIntAdd(AtomicInt* atomicInt, int value), int AtomicIntGet(AtomicInt* atomicInt) etc.
---
add command-line arg -wc to build.ts
it recursively scans all files in src/ directory and calculates total number of lines for each file extension and prints the result for .cpp, .h, .c, .txt files
---
also print number of files per extension like: .cpp: 100 lines in 28 files
---
display the output in a table-like display, 3 columns, numbers are aligned right, print the header (ext,lines,files) first and then just numbers for each row

current stats:
 ext   lines  files
.cpp  101830    175
  .h   18207    147
  .c       8      1
.txt     190      2

---
add -fix-virt flag to build.ts. It reads all .cpp and .h files in src/ directory
uses regular expression to detect a pattern, where on the same line we have:
virtual ~CommandPaletteWnd() override
i.e. virtual .* override
in lines that match that it removes virtual and following whitespace
if not lines that match, leaves the file alone
if made changes write the changed file back, make sure to preserve original line endings (crlf or lf)
---
analyze src/CommandPalette.cpp, src/CommandPalette.h, src/Commands.h, src/Commands.cpp src/Accelerators.cpp src/Accelerators.h
In CommandPaletteWnd when showing commands we also want to show the accelerator key if any, on the right side of the command name
To do that we need to do custom painting in ListBox and paint command name on the left side and accelerator key on the right side
---
it doesn't work, doesn't show any commands at all
---
it works but it needs a few pixels of spacing between the lines
---
no change, the lines still overlap
---
looks good. now add 8px right padding to accelerator key
---
split src/WinGui/WinGui.cpp into multiple files, one file for each class
name the file after class name e.g. Wnd => src/WinGui/Wnd.cpp
update visual studio solution by running: go run . -premake
build by rnning: bun build.ts
---
I got a crash:
libmupdf.dll!add_char_to_line+0xd2 \mupdf\source\fitz\stext-device.c+397
libmupdf.dll!fz_add_stext_char_imp+0x7a2 \mupdf\source\fitz\stext-device.c+860
libmupdf.dll!fz_add_stext_char+0x5fe \mupdf\source\fitz\stext-device.c+955
libmupdf.dll!flush_actualtext+0x106 \mupdf\source\fitz\stext-device.c+1087
libmupdf.dll!fz_stext_begin_metatext+0xc3 \mupdf\source\fitz\stext-device.c+1343
libmupdf.dll!fz_begin_metatext+0x67 \mupdf\source\fitz\device.c+621
libmupdf.dll!begin_metatext+0x7d \mupdf\source\pdf\pdf-op-run.c+1682
libmupdf.dll!push_marked_content+0x246 \mupdf\source\pdf\pdf-op-run.c+2126
libmupdf.dll!pdf_process_BDC+0x54 \mupdf\source\pdf\pdf-interpret.c+1233
libmupdf.dll!pdf_process_keyword+0xc1e \mupdf\source\pdf\pdf-interpret.c+1517
libmupdf.dll!pdf_process_stream+0x1d3 \mupdf\source\pdf\pdf-interpret.c+1687
libmupdf.dll!pdf_process_raw_contents+0x10b \mupdf\source\pdf\pdf-interpret.c+1827
libmupdf.dll!pdf_process_contents+0x72 \mupdf\source\pdf\pdf-interpret.c+1850
libmupdf.dll!pdf_run_page_contents_with_usage_imp+0x567 \mupdf\source\pdf\pdf-run.c+188
libmupdf.dll!pdf_run_page_contents_with_usage+0xc7 \mupdf\source\pdf\pdf-run.c+226
libmupdf.dll!pdf_run_page_contents+0x30 \mupdf\source\pdf\pdf-run.c+240
libmupdf.dll!pdf_run_page_contents_imp+0x30 \mupdf\source\pdf\pdf-page.c+1114
libmupdf.dll!fz_run_page_contents+0x8d \mupdf\source\fitz\document.c+1024
libmupdf.dll!fz_new_stext_page_from_page_with_cookie+0xe4 \mupdf\source\fitz\util.c+311
sumatrapdf.exe!EngineMupdf::ExtractPageText+0xc7 \src\EngineMupdf.cpp+3205

Most likely this line in stext-device.c:
	if (font->flags.is_bold)
crashes because font is null
analyze the code in mupdf/ directory stext-device.c, device.c, pdf-op-run.c, pdf-interpret.c and see if you can figure out sequence of actions that would lead to font being null
---
Analyze the code in ./src/previewer2
it's a dll for providing thumbnails to windows
instead of implementing thumbnails directly using Engine* classes, change the implementation to use SumatraPDF.exe executable to do the actual work
for each thumbnail create a unique, named pipe for bi-directional communication with SumatraPDF.exe process
launch SumatraPDF.exe with -preview-pipe <pipe_name>
SumatraPDF.exe waits for commands on the pipe and sends back thumbnail data
previewer sends the data via that pipe to sumatrapdf.exe
when thumnbnail is finished, terminate the process







Ideas for refactorings:

- change all size_t => int
- change use of Str::Get() => Str::CStr() (or maybe make it Str() as in StrSpan?)
- audit all str::Join() and path::Join() to see if could / should be *Temp()

------------------------------------------------------------------

static void ClearPixmap(fz_pixmap* pixmap) {
    auto stride = pixmap->stride;
    size_t dx = (size_t)pixmap->w;
    size_t dy = (size_t)pixmap->h;
    u8* samples = pixmap->samples;
    ReportIf(pixmap->n != 3);
    for (size_t y = 0; y < dy; y++) {
        u8* d = samples + (stride * y);
        for (size_t x = 0; x < dx; x++) {
            d[0] = 255;
            d[1] = 0;
            d[2] = 0;
            d += pixmap->n;
            if (false) {
                if (x % 2 == 0) {
                    *d++ = 255;
                    *d++ = 0;
                    *d++ = 0;
                } else {
                    *d++ = 0;
                    *d++ = 0;
                    *d++ = 255;
                }
            }
        }
    }
}

------------------------------------------------------------------

// Select random files to test. We want to test each file type equally, so
// we first group them by file extension and then select up to maxPerType
// for each extension, randomly, and inter-leave the files with different
// extensions, so their testing is evenly distributed.
// Returns result in <files>.
static void RandomizeFiles(StrVec& files, int maxPerType) {
    StrVec fileExts;
    Vec<StrVec*> filesPerType;

    for (int i = 0; i < files.Size(); i++) {
        char* file = files.at(i);
        char* ext = path::GetExtTemp(file);
        CrashAlwaysIf(!ext);
        int typeNo = fileExts.FindI(ext);
        if (-1 == typeNo) {
            fileExts.Append(ext);
            filesPerType.Append(new StrVec());
            typeNo = filesPerType.Size() - 1;
        }
        filesPerType.at(typeNo)->Append(file);
    }

    for (size_t j = 0; j < filesPerType.size(); j++) {
        StrVec* all = filesPerType.at(j);
        StrVec* random = new StrVec();

        for (int n = 0; n < maxPerType && all->Size() > 0; n++) {
            int idx = rand() % all->Size();
            char* file = all->at(idx);
            random->Append(file);
            all->RemoveAt(idx);
        }

        filesPerType.at(j) = random;
        delete all;
    }

    files.Reset();

    bool gotAll = false;
    while (!gotAll) {
        gotAll = true;
        for (size_t j = 0; j < filesPerType.size(); j++) {
            StrVec* random = filesPerType.at(j);
            if (random->Size() > 0) {
                gotAll = false;
                char* file = random->at(0);
                files.Append(file);
                random->RemoveAt(0);
            }
        }
    }

    for (size_t j = 0; j < filesPerType.size(); j++) {
        delete filesPerType.at(j);
    }
}

------------------------------------------------------------------

StrVec2 ideas:
- optimize for SetAt(): when removing last string from a page, free its memory (update currEnd)
- implement StrVec2::InsertAt()

------------------------------------------------------------------

struct ClosureData;
typedef void (*closureFunc)(ClosureData*);

struct ClosureData {
    closureFunc func;
    virtual ~ClosureData() = 0;
    virtual operator()() {
        func(this);
    }
};

template <typename T>
ClosureData* newClosure(void (*func)(T*)) {
    T* res = new T();
    res->func = (closureFunc)func;
    return res;
}

struct UpdateCheckData : ClosureData {
    ~UpdateCheckData() override {
    }
};

void updateCheck(UpdateCheckData* d) {
    // ...
    delete d;
}

auto res = newClosure<UpdateCheckData>(updateCheck);

------------------------------------------------------------------

Delegates ideas:
https://github.com/rosbacke/delegate
https://github.com/rosbacke/MCU-tools/tree/master/src/callback
https://github.com/Naios/function2
https://gist.github.com/twoscomplement/030818a6c38c5a983482dc3a385a3ab8
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html
https://github.com/vittorioromeo/Experiments/blob/master/function_ref.cpp
https://blog.stratifylabs.dev/device/2022-12-01-Callback-and-Lambdas-in-embedded-cpp/

CmdOpenAttachment,,Open Attachment,ver 3.6+
CmdSaveAttachment,,Save Attachment,ver 3.6+
